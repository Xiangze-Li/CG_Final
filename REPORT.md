<h1 style="text-align:center;"><small>计算机图形学 实验报告5</small><br/>真实感图形渲染</h1>
<p style="text-align:center;"><big>李祥泽</big><br/>计83 2018011331<br/>lee_johnson@qq.com</p>

## 总述 ##

为一个 Header Only 工程, C++ 源文件只有 `main.cpp`. 基础算法为 SPPM, 加分项为光线求交的 BVH 加速. 

## 算法简述 ##

### 算法选型: 随机渐进式光子映射 SPPM ###

在**光线投射**算法中, 视线依次从相机点发出, 经过画布上的每一个像素点, 击中场景中的物体. 在交点处查询每一个光源对该点的光照, 求和之后就作为该光线的颜色, 也即画布上该像素点应染上的颜色. 

显然, 这种方法不能够处理具有镜面反射或折射特性的物体, 因为视线在第一个交点处就结束了. 为了处理反射和折射, 引入**光线追踪**算法. 在光线追踪中, 视线在交点处不一定结束, 而是要做出判断: 如果交点处的物体是镜面反射的, 就按反射定律产生一条反射视线; 如果是透明的, 就按折射定律产生一条反射视线和一条折射视线; 仅当物体是漫反射的, 视线终结, 查询来自光源的光照. 一个像素的颜色是由此发出的所有视线的颜色的求和. 

如果视线在击中漫反射物体时还继续向某个方向再发出一条视线, 就成为**路径追踪**. 

光线追踪 / 路径追踪算法的一个问题是, 它无法很好地处理间接光照, 即光源经由反射, 折射甚至散射照亮另一个面. 而这部分光照是很重要的. 为了解决这个问题, 需要从光源出发计算亮度, 而不是由视点出发. 即采用**光子映射**算法. 该算法反复从光源发出光线 (光子), 令其在反射面和折射面上来回反弹, 逐次将能量 (也就是颜色) 留在面上, 最终完全被散射面吸收 (或从散射面上再向随机方向反射一小部分). 然后从视点发出视线, 按光线追踪的方法, 统计经过的交点处的光能, 作为视线的光能. 

光子映射的问题在于, 它所发出的许多光子是无效的, 但所有光子都需要被记录. 这就增加了时空复杂度, 进而限制了精度. 为此, 将光子映射的两个步骤对调. 先进行光线追踪, 计算出空间中的哪些点对像素的颜色有贡献, 将这些点组织成一个可查询的数据结构 (常用的, 也是我所采用的是 k-D 树), 然后再由光源发出光子, 只在击中这些点 (包括其邻域) 时, 更新这些点的光强. 这使得总共需要的空间不会无限增长, 进而可以无限制地发射光子 (只要时间允许), 以提高模拟的精度. 这种算法就是**渐进式光子映射**. 如果在每批光子发射完毕后重新计算依赖点, 并加入随机扰动, 就成为**随机渐进式光子映射**. 

SPPM 的过程在 `SPPM.hpp` 与 `main.cpp` 中实现. `SPPM.hpp` 中的 `sppmBacktrace()` 实现了追踪一条光线并给出沿途交点的功能, `sppmForward()` 实现了追踪光子并更新击中点光强的功能. `main.cpp` 中调用上述函数实现了 SPPM 算法的两个过程, 即由相机产生光线并建立 k-D 树, 和由光源随机产生光子更新光强. 最终由 `main.cpp` 输出一张 ppm 图片. 

### 光线求交和加速 ###

在我所完成的渲染工具中, 只实现了球体, 无穷大平面 (由于采用了包围盒求交加速, 实际上并不是无穷大的, 只有坐标值介于 $-10000$ 到 $10000$ 之间的部分会被绘制), 三角面片三种几何体. Mesh 乃是三角面片的集合. 这三种几何体的实现都在 `Obj_Geometry.hpp` 中. 

#### 球体 ####

采用几何法而不是解析法. 这样可以避免矩阵方程运算. 

#### 平面 ####

平面由其法向和一个偏移量确定, 方程表示为 $\vec{n} \cdot \vec P + d = 0$. 光线方程为 $\vec P = \vec O + t \cdot \vec r \ (t>0)$. 联立两个方程即可解得 $t = \frac{-d-\vec n\cdot \vec O}{\vec n \cdot \vec r}$. 

由于 C++ 所采用的 IEEE 754 浮点数运算标准允许将 0 作为分母 (将得到 `inf` 或 `-inf`, 视两个运算数的正负), 因此省去了判断 $\vec n \cdot \vec r$ 是否为零的步骤. 

#### 三角面 ####

三角面由三个顶点所确定, 约定顶点输入的顺序是逆时针的, 这就确定了法向的方向. 

光线将先与三个点确定的平面求交, 再做交点是否在三角形内的判断. 

#### BUG: 自遮挡 ####

由于计算误差的存在, 计算出的交点可能与射线的发出点不在物体表面的同一侧. 这样一来, 光照将不能到达该点, 从该点发出的反射线也将立即碰到物体表面. 这通常将导致大量的黑色斑点. 

为了解决这个问题, 在求出交点后要做判断和调整. 对于平面和三角面来说, 直接将交点代入方程就能得到点到平面的距离, 根据这个距离就能做出判断. 如果发现交点真的在异侧, 就将求出的参数逐步减小, 直到交点越过表面. 对于球面来说, 我并未观察到自遮挡现象, 于是没有做处理, 如果需要的话, 做法是类似的. 

但是, 解决了反射的自遮挡问题将引入折射的自遮挡, 即从交点发出的折射线将立即击中表面. 我采用的处理是, 在保证交点在射线同侧的前提下, 将折射线的发出点沿着交点处的法向向射线对侧移动一个固定距离. 理论上说, 这种方法不能保证解决所有问题, 因这个固定距离可能太小, 以至于不够越过表面, 或太大, 以至于越过了不止一个表面. 我没有处理这些可能性. 

#### 光线求交加速: 层次包围体 BVH ####

对于少量物体, 在每次求交时遍历场景是可行的. 但对于大量物体, 复杂度就太高了. 为此, 采用 AABB 和层次包围体加速. 

对于每个物体, 其 AABB 是一个能完全将其包含在内的, 所有边与坐标轴平行的长方体, 由两个顶点和长方体的中心给出, 约定第一个顶点的每个坐标都小于第二个顶点的每个坐标. 

BVH 也类似于 k-D 树, 它的每个节点都满足这样一个性质: 节点的 AABB 恰能完整地包含两个孩子的 AABB. 

在求交时, 对每个节点检查两个孩子的 AABB, 如果光线和 AABB 不相交, 就不必真正求交点, 如果和 AABB 相交, 就需要递归地测试光线与这个孩子表示的物体或物体组是否相交. 

建立 BVH 的方法是, 将传入的所有物体按其 AABB 中心的某个维度排序 (用于排序的维度是随机选的, 如果判断哪个维度的跨度最大, 则效率更高). 将其一半归于左孩子, 另一半归于右孩子, 再递归地建立两个子树. 之所以需要排序, 是为了使两个孩子的 AABB 尽可能分离, 进而提高光线与某个孩子的 AABB 不相交的几率. 

BVH 的实现在 `Obj_BVH.hpp` 中. 

由 BVH 派生出物体组 (`Group` 类, 实现在 `Obj_Group.hpp` 中) 和三角网络 (`Mesh` 类, 实现在 `Obj_Mesh.hpp`中). 这两者没有需要额外说明的特性. 

### 其他: OpenMP 加速 ###

采用 C++ 自带的 OpenMP 多线程库做加速. 

## 示例输出 ##



## 运行说明 ##

场景是被**硬编码**进 `Scene.hpp` 和 `main.cpp` 中的. 

对于需要渲染的场景, 需要建立一个 `SceneParser` 对象, 其构造函数要求以下参数: 

1.  场景的名字, `std::string`, 在实现中使用的是字符串字面量, 交由编译器做隐式转换. 
2.  相机, `Camera` 类, 其参数依次是: 视点坐标, 视线中央方向 (前方), 上方 (不要求和 "前方" 垂直), 宽度方向的视角 (角度), 画布宽度 (像素), 画布高度 (像素), 光圈. 
3.  光源, `Light *`, 只实现了点光源, 参数为: 坐标, 颜色. 
4.  场景中的物体, `std::vector<Object *>`, 每种 `Object` 派生类要求的参数不同, 但最后一项均为材质 (的指针). 
5.  背景色 (无用, 但未删去).

在 `main.cpp` 的主函数开始前, 通过 `SceneParser &scene = somewhat;` 来设定被使用的场景.  

材质同样被硬编码在该文件的一个命名空间中. 要求参数是: 颜色, 光学特性, 折射率. 

在设定好场景后可以将 `main.cpp` 编译. **要求 C++ 标准 11 以上 (`-std=c++11`) 和 OpenMP 支持 (`-fopenmp`)**. 

也可以**在代码所在目录下直接执行 `make` 命令**, 可执行文件将被输出为 `bin/main`, 这将额外加上 `-O2` 优化. 

只在 Ubuntu 20.04 LTS 和 WSL 的 Ubuntu 18.04 LTS 下测试过. 